<!DOCTYPE html>
<html lang="en" dir="ltr">
  <%- include('head.ejs',{page_name:'Trang quản lý'}) %>
  <body>
    <form action="">
      <p>NAV:</p>
      <input id="fund_nav_input"/>
      <p>Cash:</p>
      <input id="fund_cash_input"/>
    </form>

    <div style="position:relative;margin-top:30px;">
      <div id="chartContainer" style="height: 370px; width: 100%;">

      </div>
      <div id="canvasTrialHide"></div>
    </div>
    <div class="title">
      Chi tiết danh mục
    </div>
    <div class="block-content" id="currentPf"></div>

    <div class="block">
      <div class="title">
        Lịch sử lệnh
      </div>
      <div class="block-content" id="records">

      </div>
    </div>

    <script src="https://canvasjs.com/assets/script/canvasjs.min.js"></script>
    <script>
      let vnindex = <%- JSON.stringify(vnindex) %>;
      let prices = <%- JSON.stringify(prices) %>;
      let dividend = <%- JSON.stringify(dividend) %>;
      let trades = <%- JSON.stringify(trades) %>;

      //console.log(vnindex);
      //console.log(prices);
      //console.log(dividend);
      //console.log(trades);

      let testDateStart = new Date('2022-06-01');
      let testDateEnd = new Date('2022-09-30');
      let dates = getDatesInRange(testDateStart,testDateEnd);
      let tradeTickers = [...new Set(trades.map(item => item.ticker))];

      //-----------DATA cleaning-------------
      //----------------excluding dates-------------
      dividend = dividend.filter(item => dates.includes(item[2]));

      //----------------excluding tickers-----------
      dividend = dividend.filter(item => tradeTickers.includes(item[1]));
      console.log(dividend);
      //console.log(arraySize(dividend));

      let tradeCleaned = []
      for(var i=0;i<trades.length;i++) {
        try {
          let d = new Date(trades[i].order_time);
          tradeCleaned.push({
            date: addZero(d.getDate())+"/"+addZero(d.getMonth()+1)+"/"+d.getFullYear(),
            order: trades[i].order_direction.toUpperCase(),
            ticker: trades[i].ticker,
            vol: trades[i].vol,
            price: trades[i].price
          });
        } catch (err) {
          console.log(i, err);
        }
      }
      console.log(tradeCleaned);

      // ----------Portfolio construction -----------
      let initCap = 10;
      let totalCap = 0;
      let portfolio = [];
      let netCashFlow = 0;
      var records = [];  //time,direction,ticker,vol,pct,price,avg_cost,profit

      for(var t=0;t<dates.length;t++) {
        // ------------ loop through dates ----------------
        for(var i=0;i<dividend.length;i++) {
          //-----------------Looking in dividend first -------------
          if(dates[t] == dividend[i][2]) {    // Ngay GDKHQ
            for(var j=0; j<portfolio.length; j++) {  // check if portfolio has this ticker
              if(dividend[i][1] == portfolio[j].ticker) {
                console.log(portfolio.length);
                console.log('Ngày '+ dates[t] + " có cổ tức trên " + (portfolio[j].volAvailable * Math.pow(10,6)) + " cổ phiếu " + portfolio[j].ticker);
                switch(dividend[i][0]) {
                  case 'Trả cổ tức bằng cổ phiếu':
                  case 'Thưởng cổ phiếu':
                    // code block
                    console.log('Trả cổ tức bằng cổ phiếu tỷ lệ '+ dividend[i][4]);
                    try {
                      let splitRate = [parseFloat(dividend[i][4].split(":")[0]),parseFloat(dividend[i][4].split(":")[1])];
                      let pending = portfolio[j].volAvailable / splitRate[0] * splitRate[1];
                      console.log('Nhận thêm: ' + pending);
                      portfolio[j].pending += pending;
                      // update price
                      portfolio[j].buyprice = portfolio[j].eq / (portfolio[j].volAvailable + pending);
                    } catch(err) {
                      console.log(err);
                    }
                    break;
                  case 'Trả cổ tức bằng tiền mặt':
                    // code block
                    console.log('Trả cổ tức bằng tiền '+ dividend[i][4] + ' đồng/CP');
                    try{
                      let cashPerShare = parseFloat(dividend[i][4]);
                      let cashDiv = (portfolio[j].volAvailable + portfolio[j].pending) * cashPerShare / Math.pow(10,9);
                      netCashFlow += cashDiv;
                      console.log('Nhận thêm ' + cashDiv + " tỷ");
                      // update price
                      portfolio[j].buyprice -= cashPerShare / 1000;  // Not sure: what if cashPerShare > buyPrice?
                    } catch(err) {
                      console.log(err);
                    }
                    break;
                  case 'Phát hành thêm':
                    // code block
                    console.log('Phát hành thêm '+ dividend[i][4]);
                    try{
                      let issueRate = [parseFloat(dividend[i][4].split(",")[0].split(':')[0]),parseFloat(dividend[i][4].split(",")[0].split(':')[1])];
                      let issuePrice = parseFloat(dividend[i][4].split(",")[1]) / Math.pow(10,3);
                      let pending = portfolio[j].volAvailable / issueRate[0] * issueRate[1];
                      console.log('Nhận thêm: ' + pending);
                      portfolio[j].pending += pending;
                      // update price
                      portfolio[j].buyprice = (portfolio[j].eq + pending * issuePrice) / (portfolio[j].volAvailable + pending);
                    } catch(err) {
                      console.log(err);
                    }
                  default:
                    // code block
                }
              }
            }
          }
        }
        for(var i=0;i<tradeCleaned.length;i++) {
          //-----------------Looking in trades second -------------
          if(dates[t] == tradeCleaned[i].date) {
            if(tradeCleaned[i].order=="BUY") {
              if(portfolio.length==0) {
                // blank portfolio
                portfolio.push({
                  ticker: tradeCleaned[i].ticker.toUpperCase(),
                  volAvailable: tradeCleaned[i].vol,
                  buyprice: tradeCleaned[i].price,
                  eq: tradeCleaned[i].vol * tradeCleaned[i].price,
                  pending: 0
                });
                // push to records
                records.push({
                  id:0,
                  time:tradeCleaned[i].date,
                  direction:'MUA',
                  ticker:tradeCleaned[i].ticker.toUpperCase(),
                  vol:tradeCleaned[i].vol,
                  price:tradeCleaned[i].price,
                  avg_cost:tradeCleaned[i].price,
                  profit:0
                });
                netCashFlow -= tradeCleaned[i].vol * tradeCleaned[i].price;
              } else {
                // portfolio not blank
                let cnt = 0;
                for(var j=0;j<portfolio.length;j++) {
                  if(tradeCleaned[i].ticker.toUpperCase() == portfolio[j].ticker.toUpperCase()) {
                    // ticker already in portfolio
                    cnt ++;
                    portfolio[j].volAvailable += tradeCleaned[i].vol;
                    portfolio[j].eq += tradeCleaned[i].vol * tradeCleaned[i].price;
                    portfolio[j].buyprice = portfolio[j].eq/portfolio[j].volAvailable;
                    // push to records
                    records.push({
                      id:0,
                      time:tradeCleaned[i].date,
                      direction:'MUA',
                      ticker:tradeCleaned[i].ticker.toUpperCase(),
                      vol:tradeCleaned[i].vol,
                      price:tradeCleaned[i].price,
                      avg_cost:portfolio[j].eq/portfolio[j].volAvailable,
                      profit:0
                    });
                  }
                }
                if(cnt == 0) {
                  // this ticker not in portfolio
                  portfolio.push({
                    ticker: tradeCleaned[i].ticker.toUpperCase(),
                    volAvailable: tradeCleaned[i].vol,
                    buyprice: tradeCleaned[i].price,
                    eq: tradeCleaned[i].vol * tradeCleaned[i].price,
                    pending: 0
                  });
                  records.push({
                    id:0,
                    time:tradeCleaned[i].date,
                    direction:'MUA',
                    ticker:tradeCleaned[i].ticker.toUpperCase(),
                    vol:tradeCleaned[i].vol,
                    price:tradeCleaned[i].price,
                    avg_cost:tradeCleaned[i].price,
                    profit:0
                  });
                }
                netCashFlow -= tradeCleaned[i].vol * tradeCleaned[i].price;
              }
            } else {
              // SELL order
              if(portfolio.length>0) {
                for(var j=0;j<portfolio.length;j++) {
                  if(tradeCleaned[i].ticker.toUpperCase() == portfolio[j].ticker.toUpperCase()) {
                    // ticker already in portfolio
                    if(portfolio[j].volAvailable - tradeCleaned[i].vol <= 0) {
                      // Sell amount is bigger than available
                      portfolio[j].volAvailable = 0;
                      portfolio[j].eq = portfolio[j].buyprice * portfolio[j].pending;
                      //portfolio[j].buyprice = 0;
                      netCashFlow += portfolio[j].volAvailable * tradeCleaned[i].price;
                    } else {
                      portfolio[j].volAvailable -= tradeCleaned[i].vol;
                      portfolio[j].eq -= tradeCleaned[i].vol * tradeCleaned[i].price;
                      if(portfolio[j].eq < 0) portfolio[j].eq = 0;
                      netCashFlow += tradeCleaned[i].vol * tradeCleaned[i].price;
                    }
                    // push to records
                    records.push({
                      id:0,
                      time:tradeCleaned[i].date,
                      direction:'BÁN',
                      ticker:tradeCleaned[i].ticker.toUpperCase(),
                      vol:tradeCleaned[i].vol,
                      price:tradeCleaned[i].price,
                      avg_cost:portfolio[j].buyprice,
                      profit:((tradeCleaned[i].price-portfolio[j].buyprice)/portfolio[j].buyprice)*100
                    });
                  }
                }
              }
            }
          }
        }

        // --------------------record to snapShot------------
        console.log(dates[t]);
        //console.log(JSON.stringify(portfolio));
        console.log("net cashflow: ",netCashFlow);
      }

      // -------------Update current price --------------
      for(var i=0; i<prices.length; i++){
        for(var j=0;j<portfolio.length;j++){
          if(prices[i][0] == portfolio[j].ticker) {
            try {
              portfolio[j].price = parseFloat(prices[i][2]);
              portfolio[j].cap = (portfolio[j].volAvailable + portfolio[j].pending) * portfolio[j].price;
            } catch(err) {
              console.log(err);
            }
          }
        }
      }


      //--------------NAV calculation----------
      for(var i=0;i<portfolio.length;i++) {
        if(!portfolio[i].hasOwnProperty('price')) {
          portfolio[i].price = portfolio[i].buyprice;
          portfolio[i].cap = portfolio[i].eq;
        }
        totalCap += portfolio[i].cap;
      }
      console.log(portfolio);
      let cash = initCap + netCashFlow;
      totalCap += cash;
      console.log(totalCap);
      // then update NAV values to DB

      // update NAV and cash inputs
      document.getElementById('fund_nav_input').value = (totalCap * Math.pow(10,9)).toLocaleString('en');
      document.getElementById('fund_cash_input').value = (cash * Math.pow(10,9)).toLocaleString('en');

      //-----------Portfolio table rendering------------
      let pfTableContent = '<table style="margin-top:30px;width:100%;text-align:center"><tr><th>Mã</th><th>Khối lượng</th><th>Khả dụng</th><th>Chờ nhận</th><th>Giá vốn TB</th><th>Giá hiện tại</th><th>Giá trị mua</th><th>Giá trị hiện tại</th><th>Lãi/lỗ</th><th>Lãi/lỗ (%)</th></tr>';
      for(var i=1; i<portfolio.length; i++) {
        let color = '';
        if(portfolio[i].price > portfolio[i].buyprice) color='text-success';
        if(portfolio[i].price < portfolio[i].buyprice) color='text-danger';
        let prfPct = (portfolio[i].price - portfolio[i].buyprice)/portfolio[i].buyprice * 100;
        pfTableContent += '<tr><td>' + portfolio[i].ticker +
        '</td><td>'+ (portfolio[i].volAvailable * Math.pow(10,6)).toLocaleString('en') +
        '</td><td>'+ (portfolio[i].volAvailable * Math.pow(10,6)).toLocaleString('en') +
        '</td><td>'+ (portfolio[i].pending * Math.pow(10,6)).toLocaleString('en') +
        '</td><td>'+ portfolio[i].buyprice.toFixed(3) +
        '</td><td>' + portfolio[i].price.toFixed(3) +
        '</td><td>' + (portfolio[i].eq * Math.pow(10,9)).toLocaleString('en',{
            minimumFractionDigits: 0,
            maximumFractionDigits: 0,
        }) +
        '</td><td>' + (portfolio[i].cap * Math.pow(10,9)).toLocaleString('en',{
            minimumFractionDigits: 0,
            maximumFractionDigits: 0,
        }) +
        '</td><td class="'+color+'">' + ((portfolio[i].cap - portfolio[i].eq) * Math.pow(10,9)).toLocaleString('en',{
            minimumFractionDigits: 0,
            maximumFractionDigits: 0,
        }) +
        '</td><td class="'+color+'">'+prfPct.toFixed(2)+' %</td></tr>';
      }
      pfTableContent += '</table>';
      document.getElementById('currentPf').innerHTML=pfTableContent;

      //-----------Trades record table rendering--------------------
      let recordTableContent = '<table style="margin-top:30px;width:100%;text-align:center"><tr><th style="display:none">id</th><th>Ngày</th><th>Lệnh</th><th>Mã</th><th>Khối lượng</th><th>Giá</th><th>Giá vốn TB</th><th>Lãi/lỗ</th></tr>';
      for(var i=records.length-1; i>=0; i--){
        var profitDisplay='',
            profitStyle='';
        if(records[i].profit>0) {
          profitDisplay=records[i].profit.toFixed(2)+' %';
          profitStyle='text-success';
        }
        if(records[i].profit<0) {
          profitDisplay=records[i].profit.toFixed(2)+' %';
          profitStyle='text-danger';
        }
        var dt = records[i].time;
        recordTableContent+='<tr><td  style="display:none">'+records[i].id+'</td><td>'+dt+'</td><td>'+records[i].direction+'</td><td>'+records[i].ticker+'</td><td>'+(records[i].vol*1000000).toLocaleString('en')+'</td><td>'+records[i].price+'</td><td>'+records[i].avg_cost.toFixed(2)+'</td><td class="'+profitStyle+'">'+profitDisplay+'</td></tr>';
      }
      recordTableContent+='</table>';

      let  recordTable = document.getElementById('records');
      if(recordTable!=null){
        recordTable.innerHTML = recordTableContent;
      }

      //-----------Chart rendering-----------
      //-----------------Pie chart----------------
      let portfolioChartData=[];
      let stock_pct=0;
      for(var i=0;i<portfolio.length;i++){
        if((portfolio[i].volAvailable + portfolio[i].pending)>0){
          portfolioChartData.push({y:(portfolio[i].cap/totalCap*100).toFixed(2),label:portfolio[i].ticker});
          stock_pct+=portfolio[i].cap/totalCap*100;
          //console.log(portfolio[i].cap/totalCap*100,stock_pct);
        }
      }
      portfolioChartData.push({y:100-stock_pct,label:'Tiền mặt'});

      var chartPie0 = new CanvasJS.Chart("chartContainer", {
      	animationEnabled: true,

        backgroundColor: "rgba(0,0,0,0)",
      	data: [{
      		type: "pie",
      		startAngle: 240,
      		yValueFormatString: "##0.00\"%\"",
      		indexLabel: "{label} {y}",
          indexLabelFontColor: "white",
      		dataPoints: portfolioChartData/*[
      			{y: 79.45, label: "Google"},
      			{y: 7.31, label: "Bing"},
      			{y: 7.06, label: "Baidu"},
      			{y: 4.91, label: "Yahoo"},
      			{y: 1.26, label: "Others"}
      		]*/
      	}]
      });
      chartPie0.render();



      // ----------Support functions---------
      function addZero(numb) {
        if(numb<10){
          return "0"+numb;
        } else {
          return ""+numb;
        }
      }

      function getDatesInRange(startDate, endDate) {
        const date = new Date(startDate.getTime());
        const dates = [];
        while (date <= endDate) {
          let d = new Date(date);
          //if(d.getDay()%6!=0) {  // weekend not included
            dates.push(addZero(d.getDate())+"/"+addZero(d.getMonth()+1)+"/"+d.getFullYear());
          //}
          date.setDate(date.getDate() + 1);
        }
        return dates;
      }

      function arraySize(arr){
        return {r: arr.length, c:arr[0].length === undefined?1:arr[0].length };  // {r: 1, c: 5}
      }

    </script>
  </body>
</html>
